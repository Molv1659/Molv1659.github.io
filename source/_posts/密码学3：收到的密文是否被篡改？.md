---
title: 密码学3：收到的密文是否被篡改？
date: 2021/02/26 01:01:03
photos: https://github.com/Molv1659/molv1659.github.io/tree/main/cdn/article-covers/6.PNG
categories: 砂糖实验室
avatar: https://github.com/Molv1659/molv1659.github.io/tree/main/cdn/kirito1.jpg
authorLink: http://www.sisicheng.com
---
permalink: hash
前面已讲了加密通信的机密性和端点鉴别，这期讲讲怎么保证密文完整性，即你收到了友人A发过来的密文，虽然你知道黑客截下来也看不懂，但你怎么知道这个密文是不是被黑客改过的呢？

机智的小伙伴已经想到了，还是数字签名那期的方法呗，友人A发送密文内容为f_public_you（m，f_private_A（m））其中f_public_you（）表示用你的公钥加密，f_private_A（）表示用友人A的私钥加密。

那么你收到密文后，首先用你的私钥解密，得到内容m，f_private_A（m），然后再用友人A的公钥解密f_private_A（m），看得到的结果是否与m相同，相同则文件是完整的，否则文件内容被篡改过。设想一下如果黑客截下来后改过内容，在他没有友人A的私钥的情况下，黑客随便一改m，f_private_A（m）就不再能保证匹配了，就会露馅（即使黑客知道友人A私钥，改内容同时保证两者匹配性也很难）

但是上面的方法存在一个问题，非对称加密系统的效率是很低的，这样把全文m都加密再解密显然过于费事儿，我们可以改进一下。

首先上引理233333

# 哈希函数=散列函数

设有一段任意长度序列m，哈希函数H，则H（m）是哈希函数结果，其长度为固定值。可以看到哈希函数就是一个投影，把任意长度的序列投影到固定长度上。一个设计优秀的哈希函数（比如MD5等等）能使过程是一个单向操作，即很很恨很难从H（m）的值逆推出m。且通常输入m改变一点，结果H（m）就可能相差很多。

# 方法

那么原本f_private_A（m）我们可以改为f_private_A（H（m）），其中H（m）通常可以设定为1024bit这样的，比原文m短很多，对其进行加密解密就会效率提升很多。你收到A的密文并全部解密后得到m和H（m），然后自己拿收到的m代入H算一下，看和收到的H（m）是否相等即可。

由于H（m）的特性，友人A写完m后去算H（m），之后m只要有改动（比如变成m1）那么H（m1）就不等于H（m）了，所以在提高效率的同时保证了密文完整性，这是现在常用的方法。